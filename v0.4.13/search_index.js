var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Primary-citations","page":"References","title":"Primary citations","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"If this package was useful to you, please cite the following papers:","category":"page"},{"location":"references/","page":"References","title":"References","text":"L. Martínez, ComplexMixtures.jl: ComplexMixtures.jl: Understanding the solvation   of molecules of complex structure To be published, 2021.\nL. Martínez, S. Shimizu, Molecular interpretation of preferential interactions in protein solvation: a solvent-shell perspective by means of minimum-distance distribution functions. J. Chem. Theor. Comp. 13, 6358–6372, 2017. [Full Text]","category":"page"},{"location":"references/#Related-work","page":"References","title":"Related work","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"V. Piccoli, L. Martínez, Correlated counterion effects in the solvation of proteins by ionic-liquids. J. Mol. Liq. 320, 114347, 2020. [Full Text]\nI. P. de Oliveira, L. Martínez, The shift in urea orientation at protein surfaces at low pH is compatible with a direct mechanism of protein denaturation. Phys. Chem. Chem. Phys. 22, 354-367, 2020. [Full Text]\nI. P. de Oliveira, L. Martínez, Molecular basis for competitive solvation of the Burkholderia cepacia lipase by sorbitol and urea. Phys. Chem. Chem. Phys. 18, 21797-21808, 2016. [Full Text]","category":"page"},{"location":"results/#results","page":"Results","title":"Results","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"The results of a MDDF calculation are returned in a data structure which contains  the MDDF, KB integrals, and atomic contributions. The following section will assume that the computation was performed by calling the mddf function with ","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"results = ComplexMixtures.mddf(trajectory)","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"such that the results variable contain the Result data structure. By default, the histograms contain 500 bins (binstep=0.002 and cutoff=10.) such that all data-vectors will contain 500 lines.","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"To know how to save and load saved data, read the next section.","category":"page"},{"location":"results/#The-Result-data-structure:-main-data","page":"Results","title":"The Result data structure: main data","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"The most important data to be read from resutls are the distances, minimum-distance distribution function, and KB integrals. These data is stored in the following vectors:","category":"page"},{"location":"results/#Distances-of-the-histograms:-results.d","page":"Results","title":"Distances of the histograms: results.d","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"The following vector will contain values ranging from 0. to cutoff, and the distance at each bin is the distance in that bin for which half of the volume of the bin is within d, and half of the volume is above d, if the volume was spherical: ","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"julia> results.d\n500-element Array{Float64,1}:\n 0.015874010519682\n 0.033019272488946275\n ⋮\n 9.970010030080179\n 9.99001000999998\n","category":"page"},{"location":"results/#Minimum-distance-distribution-function:-results.mddf","page":"Results","title":"Minimum-distance distribution function: results.mddf","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"The results.mddf vector will contain the main result, which the minimum-distance distribution function. For a properly-sampled simulation, it will be zero at very short distances and converge to 1.0 for distances smaller than the cutoff:","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"julia> results.mddf\n500-element Array{Float64,1}:\n 0.0\n 0.0\n     ⋮\n 0.999052514965403\n 1.001030818286187\n","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"A typical plot of results.mddf as a function of results.d will look like:","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"<img src=\"../figures/mddf.png\" width=\"60%\">","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"Thus, this plot was obtained with the following code:","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"using Plots\nplot(results.d,results.mddf,xlabel=\"d/A\",ylabel=\"mddf(d) / L/mol\") ","category":"page"},{"location":"results/#Kirkwood-Buff-integral:-results.kb","page":"Results","title":"Kirkwood-Buff integral: results.kb","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"The results.kb vector will contain the Kirkwood-Buff integral computed as a function of the minimum-distance to the solute. For properly sampled simulations, it is expected to converge at large distances.  ","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"julia> results.kb\n500-element Array{Float64,1}:\n     0.0\n    -0.3249356504752985\n    -2.9804719721525\n     ⋮\n    0.72186381783\n    1.13624162115\n","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"A typical plot of results.kb as a function of results.d will look like:","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"<img src=\"../figures/kb.png\" width=\"60%\">","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"Thus, this plot was obtained with the following code:","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"using Plots\nplot(results.d,results.kb,xlabel=\"d/A\",ylabel=\"mddf(d) / L/mol\") ","category":"page"},{"location":"results/#Units","page":"Results","title":"Units","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"The distance is assumed to be in Å, as this is the most common distance units in molecular simulations. The coordinates of the atoms are assumed be provided in Å. \nThe minimum-distance distribution function is unit-less, since it is the ratio of the density at each distance divided by an ideal-gas density.\nThe Kirkwood-Buff integrals are returned in cm³ mol⁻¹, if the coordinates were provided in Å.","category":"page"},{"location":"results/","page":"Results","title":"Results","text":"warning: Warning\nIf the coordinates are not in Å, the calculation will  proceed normaly, but the units of the KB integrals, which has units of volume per mol, should be converted to conform the length unit provided. ","category":"page"},{"location":"mddf/#Computing-the-Minimum-Distance-Distribution-Function","page":"Computing the MDDF","title":"Computing the Minimum-Distance Distribution Function","text":"","category":"section"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"The main function of the ComplexMixtures package actually computes the MDDF between the solute and the solvent chosen. ","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"It is run with the following command:","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"results = ComplexMixtures.mddf(trajectory)  ","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"The MDDF along with other results, like the corresponding KB integrals, are returned in the results data structure, which is described in the next section.","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"It is possible to tune several options of the calculation, by setting the Options data structure with user-defined values in advance. The most common parameters to be set by the user are probably dbulk and stride. ","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"dbulk defines the distance from the solute above which the user believes that the reference solute molecule does not significantly anymore the structure of the solvent. The default value is 10 Angstroms, but for large solvent molecules this might not be enough. To increase dbulk, use:  ","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"options = ComplexMixtures.Options(dbulk=15.)\nresults = ComplexMixtures.mddf(trajectory,options)","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"stride defines if some frames will be skip during the calculation (for speedup). For example, if stride=5, only one in five frames will be considered. Adjust stride with:  ","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"options = ComplexMixtures.Options(stride=5)\nresults = ComplexMixtures.mddf(trajectory,options)","category":"page"},{"location":"mddf/","page":"Computing the MDDF","title":"Computing the MDDF","text":"See the Options section for further details and other options to set.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"First you need to install the Julia language in your platform, from:  http://julialang.org. Julia version 1.5 or greater is required.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Next, run julia, and within the julia REPL interface, install the ComplexMixtures package using","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> import Pkg\n\njulia> Pkg.add(\"ComplexMixtures\")\n","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or simply","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ] add ComplexMixtures\n","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To follow all the examples provided in this manual, the  PDBTools  and Plots have to be installed as well:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ] add PDBTools, Plots\n","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are first-time julia user, load these packages for the first time after installation. Loading the Plots package, in particular, may take quite a while when done for the first time, because it is compiled at this point (this was greatly improved in Julia versions greater than 1.6, which are highly recommended). To load the packages, use:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using ComplexMixtures, PDBTools, Plots","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If no errors were shown in any of these steps, the packages are ready to be used following the instructions and examples.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"tip: Tip\nThe functions of the package are called, for example, using ComplexMixtures.mddf(...). To avoid having to write ComplexMixtures all the time, define an accronym. For example:using ComplexMixtures ; const CM = ComplexMixtures\nCM.mddf(...)\n","category":"page"},{"location":"contrib/#contrib","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"","category":"section"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"One of the interesting features of Minimum-Distance distributions is that they can be naturally decomposed into the atomic or group contributions. Simply put, if a MDDF has a peak at a hydrogen-bonding distance, it is natural to decompose that peak into the contributions of each type of solute or solvent atom to that peak.     ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"To obtain the atomic contributions of an atom or group of atoms, the ComplexMixtures.contrib functions are provided. For example, in a system composed of a protein and water, we would have defined the solute and solvent using:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"atoms = PDBTools.readPDB(\"system.pdb\")\nsolute = PDBTools.select(atoms,\"protein\",nmols=1)\nsolvent = PDBTools.select(atoms,\"water\",natomspermol=3)","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The MDDF calculation is executed with:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"trajectory = ComplexMixtures.Trajectory(\"trajectory.dcd\",solute,solvent)\nresults = ComplexMixtures.mddf(trajectory)","category":"page"},{"location":"contrib/#Atomic-contributions-in-the-result-data-structure","page":"Atomic and group contributions","title":"Atomic contributions in the result data structure","text":"","category":"section"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The results data structure contains the decomposition of the MDDF into the contributions of every type of atom of the solute and the solvent. These data is available at the results.solute_atom and results.solvent_atom arrays: ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"julia> results.solute_atom\n50×1463 Array{Float64,2}:\n 0.0  0.0      0.0  …  0.0  0.0  0.0\n 0.0  0.0      0.0  …  0.0  0.0  0.0\n ...\n 0.0  0.14245  0.0  …  0.0  0.0  0.0\n 0.0  0.0      0.0  …  0.0  0.0  0.0\n\njulia> results.solvent_atom \n50×3 Array{Float64,2}:\n 0.0        0.0        0.0 \n 0.0        0.0        0.0 \n ...\n 0.26087    0.26087    0.173913\n 0.25641    0.0854701  0.170940\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"Here, 50 is the number of bins of the histogram, whose distances are available at the results.d vector.","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"It is expected that for a protein most of the atoms do not contribute to the MDDF, and that all values are zero at very short distances, smaller than the radii of the atoms.","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The three columns of the results.solvent_atom array correspond to the thee atoms of the water molecule in this example. The sequence of atoms correspond to that of the PDB file, but can be retrieved with:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"julia> solvent.names\n3-element Array{String,1}:\n \"OH2\"\n \"H1\"\n \"H2\"\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"Therefore, if the first column of the results.solvent_atom vector is plotted as a function of the distances, one gets the contributions to the MDDF of the Oxygen atom of water. For example, here we plot the total MDDF and the Oxygen contributions: ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"using Plots\nplot(results.d,results.mddf,label=\"Total MDDF\",linewidth=2)\nplot!(results.d,results.solvent_atom[:,1],label=\"OH2\",linewidth=2)\nplot!(xlabel=\"Distance / Å\",ylabel=\"MDDF\")\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"<img src=\"../figures/oh2.png\" width=\"60%\">","category":"page"},{"location":"contrib/#Selecting-groups-by-atom-names-or-indexes","page":"Atomic and group contributions","title":"Selecting groups by atom names or indexes","text":"","category":"section"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"To plot the contributions of the hydrogen atoms of water to the total MDDF, we have to select the two atoms, named H1 and H2. The ComplexMixtures.contrib function provides several practical ways of doing that, with or without the use of PDBTools. ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The ComplexMixtures.contrib function receives three parameters: ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The solute or solvent data structure, created with ComplexMixtures.Selection. \nThe array of atomic contributions (here results.solute_atom or results.solvent_atom), corresponding to the selection in 1.\nA selection of a group of atoms within the molecule of interest, provided as described below. ","category":"page"},{"location":"contrib/#Selecting-by-indexes-within-the-molecule","page":"Atomic and group contributions","title":"Selecting by indexes within the molecule","text":"","category":"section"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"To select simply by the index of the atoms of the molecules, just provide a list of indexes to the ComplexMixtures.contrib function. For example, to select the hydrogen atoms, which are the second and third atoms of the  water molecule, use:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"julia> indexes = [ 2, 3 ]\njulia> h_contrib = ComplexMixtures.contrib(solvent,R.solvent_atom,indexes)\n500-element Array{Float64,1}:\n 0.0\n 0.0\n ⋮\n 0.7742706465861815\n 0.8084139794974875\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"Plotting both the oxygen (index = 1) and hydrogen contributions results in:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"<img src=\"../figures/h_and_oh2.png\" width=\"60%\">\n","category":"page"},{"location":"contrib/#Selecting-by-atom-name","page":"Atomic and group contributions","title":"Selecting by atom name","text":"","category":"section"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The exact same plot above could be obtained by providing lists of atom names instead of indexes to the ComplexMixtures.contrib function:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"oxygen = [\"OH2\"]\no_contrib = ComplexMixtures.contrib(solvent,R.solvent_atom,oxgyen) \nhydrogens = [\"H1\",\"H2\"]\nh_contrib = ComplexMixtures.contrib(solvent,R.solvent_atom,hydrogens)\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The above plot can be obtained with:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"using Plots\nplot(results.d,results.mddf,label=\"Total MDDF\",linewidth=2)\nplot!(results.d,o_contrib,label=\"OH2\",linewidth=2)\nplot!(results.d,h_contrib,label=\"Hydrogen atoms\",linewidth=2)\nplot!(xlabel=\"Distance / Å\",ylabel=\"MDDF\")\n","category":"page"},{"location":"contrib/#General-selections-using-PDBTools","page":"Atomic and group contributions","title":"General selections using PDBTools","text":"","category":"section"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"More interesting and general is to select atoms of a complex molecule, like a protein, using residue names, types, etc. Here we illustrate how this is done by providing selection strings to ComplexMixtures.contrib to obtain the contributions to the MDDF of different types of residues of a protein to the total MDDF. ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"For example, if we want to split the contributions of the charged and neutral residues to the total MDDF distribution, we could use to following code. Here, solute refers to the protein.","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"charged_residues = PDBTools.select(atoms,\"charged\")\ncharged_contrib = ComplexMixtures.contrib(solute,R.solute_atoms,charged_residues)\n\nneutral_residues = PDBTools.select(atoms,\"neutral\")\nneutral_contrib = ComplexMixtures.contrib(solute,R.solute_atoms,neutral_residues)\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"The charged and neutral outputs are vectors containing the contributions of these residues to the total MDDF. The corresponding plot is:   ","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"plot(results.d,results.mddf,label=\"Total MDDF\",linewidth=2)\nplot(results.d,charged_contrib,label=\"Charged residues\",linewidth=2)\nplot!(results.d,neutral_contrib,label=\"Neutral residues\",linewidth=2)\nplot!(xlabel=\"Distance / Å\",ylabel=\"MDDF\")\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"Resulting in:","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"<img src=\"../figures/charged_and_neutral.png\" width=\"60%\">\n","category":"page"},{"location":"contrib/","page":"Atomic and group contributions","title":"Atomic and group contributions","text":"Note here how charged residues contribute strongly to the peak at hydrogen-bonding distances, but much less in general. Of course all selection options could be used, to obtain the contributions of specific types of residues, atoms, the backbone, the side-chains, etc. ","category":"page"},{"location":"parallel/#Parallel-execution","page":"Parallel execution","title":"Parallel execution","text":"","category":"section"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"An MDDF calculation can be performed in parallel, using many processors of a  single computer. The speedup is almost linear, as the parallelization is performed by splitting the calculation of each frame in each processor, in an asynchronous manner. To run the computation in parallel, just define the number of threads (processors) to be used, by defining the JULIA_NUM_THREADS environment variable:","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"or, which is more simple in Julia 1.5 or greater, just start julia with:  ","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"julia -t 4 ","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"To directly run a script, use","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"julia -t 4 example.jl\n","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"note: Note\nThe number of threads used for computation of the MDDF is the number of defined threads minus one, because one thread is dedicated to control the execution. Since the control of the execution is not  very demanding, particularly if the number of threads is small,  you may want to set the number of threads as one  more than you originally intended, if the total number of threads is not very large. In particular, running with only -t 2 will  not parallelize the calculation at all.","category":"page"},{"location":"parallel/","page":"Parallel execution","title":"Parallel execution","text":"warning: Warning\nIf the calculations get Killed by no apparent reason, that is probably because you are running out of memory because of the many parallel computations running. One way to aleviate this problem is to force garbage collection, usingoptions = ComplexMixtures.Options(GC=true,GC_threshold=0.5)\nR = ComplexMixtures.mddf(trajectory,options)\nThe GC_threshold=0.5 indicates that if the free memory is smaller than 50% of the total memory of the machine, a garbage-collection run will occur. The   default parameters are GC=true and GC_threshold=0.1.  Unfortunately, this may slow the calculations quite a bit, and the parallelization to many processors becomes not very satisfactory. We are working to improve this.","category":"page"},{"location":"multiple/#Working-with-multiple-trajectories","page":"Multiple trajectories","title":"Working with multiple trajectories","text":"","category":"section"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"Very commonly, one has multiple trajectories of the same system, and we want to obtain the average results of all trajectories. We provide a simple scheme to average the results of multiple MDDF calculations:","category":"page"},{"location":"multiple/#Create-a-vector-of-result-data-structures,-without-initialization","page":"Multiple trajectories","title":"Create a vector of result data structures, without initialization","text":"","category":"section"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"Let us assume that we have three Gromacs trajectories, with file names traj1.xtc, traj2.xtc, traj3.xtc. First let us create a list with these file names:","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"trajs = [ \"traj1.xtc\" , \"traj2.xtc\" , \"traj3.xtc\" ]","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"And define a vector of ComplexMixtures.Result types with 3 positions, with undefined initialization:","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"results = Vector{ComplexMixtures.Result}(undef,3)","category":"page"},{"location":"multiple/#Run-the-calculations-in-a-loop","page":"Multiple trajectories","title":"Run the calculations in a loop","text":"","category":"section"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"The calculation on the multiple trajectories is then performed in a simple loop, such as","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"atoms = PDBTools.readPDB(\"./system.pdb\")\nsolute = ComplexMixtures.Selection(atoms,\"protein\",nmols=1)\nsolvent = ComplexMixtures.Selection(atoms,\"resname TMAO\",,natomspermol=14)\nfor i in 1:3 # alternatively use 1:length(trajs) \n  trajectory = ComplexMixtures.Trajectory(trajs[i],solute,solvent)\n  results[i] = ComplexMixtures.mddf(trajectory)\nend","category":"page"},{"location":"multiple/#Merge-the-results-of-several-trajectories,-with-proper-weights","page":"Multiple trajectories","title":"Merge the results of several trajectories, with proper weights","text":"","category":"section"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"Of course, the resulting results vector will contain at each position the results of each calculation. To merge these results in a single result data structure, use:","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"R = ComplexMixtures.merge(results)","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"The R structure generated contains the averaged results of all calculations, with weights proportional to the number of frames of each trajectory. That is, if the first trajectory had 2000 frames, and the second and third trajectories have 1000 frames each, the first trajectory will have a weight of 0.5 on the final results. The merge function can be used to merge previously merged results with new results as well.","category":"page"},{"location":"multiple/","page":"Multiple trajectories","title":"Multiple trajectories","text":"tip: Tip\nThe names of the files and and weights are stored in the R.files and R.weights vectors of the results structure:julia> R.files\n3-element Array{String,1}:\n \"./traj1.xtc\"\n \"./traj2.xtc\"\n \"./traj3.xtc\"\n\njulia> R.weights\n2-element Array{Float64,1}:\n 0.5\n 0.25\n 0.25\nIt is not a bad idea to check if that is what you were expecting.","category":"page"},{"location":"save/#save","page":"Save and load","title":"Save and load results","text":"","category":"section"},{"location":"save/","page":"Save and load","title":"Save and load","text":"Three functions serve the purpose of saving and loading the results obtained with ComplexMixtures:","category":"page"},{"location":"save/#Save-data-to-recover-it-later","page":"Save and load","title":"Save data to recover it later","text":"","category":"section"},{"location":"save/","page":"Save and load","title":"Save and load","text":"ComplexMixtures.save(results,\"results.json\")","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"where results is the output data structure of the ComplexMixtures.mddf() calculation, and results.json is the output file to be created. The file is written in JSON format, thus is not naturally human-readable.","category":"page"},{"location":"save/#Load-saved-data","page":"Save and load","title":"Load saved data","text":"","category":"section"},{"location":"save/","page":"Save and load","title":"Save and load","text":"results = ComplexMixtures.load(\"results.json\")","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"The ComplexMixtures.load function reads the output of the save function above, and restores the results data structure.","category":"page"},{"location":"save/#Write-data-in-a-human-readable-format","page":"Save and load","title":"Write data in a human-readable format","text":"","category":"section"},{"location":"save/","page":"Save and load","title":"Save and load","text":"If you Want the results to be written as simple ASCII tables such that you can read them with another analysis program, plotting graphic, or just want to inspect the data visually, use:","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"ComplexMixtures.write(results,\"results.dat\")","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"Three files will be created by this function:","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"results.dat: Contains the main results, as the MDDF and KB-integral data.","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"results-ATOM_CONTRIB_SOLVENT.dat: contains the contribution of each atom type of the solvent to the MDDF.","category":"page"},{"location":"save/","page":"Save and load","title":"Save and load","text":"results-ATOM_CONTRIB_SOLUTE.dat: contains the contribution of each atom type of the solute to the MDDF.","category":"page"},{"location":"trajectory/#trajectories","page":"Loading the trajectory","title":"Loading trajectories","text":"","category":"section"},{"location":"trajectory/","page":"Loading the trajectory","title":"Loading the trajectory","text":"To initialize a trajectory file for computation, use the command","category":"page"},{"location":"trajectory/","page":"Loading the trajectory","title":"Loading the trajectory","text":"trajectory = ComplexMixtures.Trajectory(\"trajectory.xtc\",solute,solvent)","category":"page"},{"location":"trajectory/","page":"Loading the trajectory","title":"Loading the trajectory","text":"where solute and solvent are defined with the Selection function  described before. This function opens the stream for reading frames, which are read once a time when the coordinates are required for computing the MDDF.","category":"page"},{"location":"trajectory/","page":"Loading the trajectory","title":"Loading the trajectory","text":"The Trajectory function uses Chemfiles in background, and thus the most common trajectory formats are supported, as the ones produced with NAMD, Gromacs, LAMMPS, Amber, etc.  ","category":"page"},{"location":"trajectory/","page":"Loading the trajectory","title":"Loading the trajectory","text":"tip: Tip\nThe format of the trajectory file is automatically determined by Chemfiles from the extension of the file. However, it can be provided by the user with the format keyword, for example:trajectory = ComplexMixtures.Trajectory(\"trajectory.xtc\",solute,solvent,format=\"xtc\")","category":"page"},{"location":"trajectory/","page":"Loading the trajectory","title":"Loading the trajectory","text":"note: Note\nThe trajectory stream is closed at the end of the MDDF computation. Therefore if you want to reuse the same trajectory for another MDDF  computation in the same script, you need to reload it. For example:solute = ComplexMixtures.Selection(\"system.pdb\",\"protein\",nmols=1)\n# Compute the protein-water MDDF\nsolvent = ComplexMixtures.Selection(\"system.pdb\",\"water\",natomspermol=3)\ntrajectory = ComplexMixtures.Trajectory(\"trajectory.xtc\",solute,solvent)\nR_water = ComplexMixtures.mddf(trajectory)\n# Compute the protein-urea MDDF\nsolvent = ComplexMixtures.Selection(\"system.pdb\",\"resname URE\",natomspermol=8)\ntrajectory = ComplexMixtures.Trajectory(\"trajectory.xtc\",solute,solvent)\nR_urea = ComplexMixtures.mddf(trajectory)","category":"page"},{"location":"quickguide/#Quick-Guide","page":"Quick Guide","title":"Quick Guide","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Of course, follow the installation instructions first.  A complete working example is shown below, and in the section that follows each  command is described in detail.","category":"page"},{"location":"quickguide/#Complete-example","page":"Quick Guide","title":"Complete example","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Here we show the input file required for the study of the solvation of a protein by the TMAO solvent, which is a molecule 4 atoms. The protein is assumed to be at infinite dilution in the simulation. The trajectory of the simulation is in DCD format in this example, which is the default output of NAMD and CHARMM simulation packages.","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"# Load packages\nusing PDBTools\nusing ComplexMixtures \nusing Plots\n\n# Load PDB file of the system\natoms = readPDB(\"./system.pdb\")\n\n# Select the protein and the TMAO molecules\nprotein = select(atoms,\"protein\")\ntmao = select(atoms,\"resname TMAO\")\n\n# Setup solute and solvent structures\nsolute = ComplexMixtures.Selection(protein,nmols=1)\nsolvent = ComplexMixtures.Selection(tmao,natomspermol=14)\n\n# Setup the Trajectory structure\ntrajectory = ComplexMixtures.Trajectory(\"./trajectory.dcd\",solute,solvent)\n\n# Run the calculation and get results\nresults = ComplexMixtures.mddf(trajectory)\n\n# Save the reults to recover them later if required\nComplexMixtures.save(results,\"./results.json\")\n\n# Plot the some of the most important results \nplot(results.d,results.mddf,xlabel=\"d\",ylabel=\"MDDF\") # plot the MDDF\nsavefig(\"./mddf.pdf\")\nplot(results.d,results.kb,xlabel=\"d\",ylabel=\"KB\") # plot the KB \nsavefig(\"./kb.pdf\")\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Given that this code is saved into a file named example.jl,  it can be run within the Julia REPL with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"julia> include(\"example.jl\")\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"or directly with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"% julia -t 5 example.jl\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"where -t 5 is optional and defines how many processors will be used in the calculation (use, for maximal performance, the number of physical cores of your computer, plus one).  ","category":"page"},{"location":"quickguide/#Detailed-description-of-the-example","page":"Quick Guide","title":"Detailed description of the example","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Start julia and load the ComplexMixtures package, using:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"using ComplexMixtures","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"And here we will use the PDBTools package to obtain the selections of the solute and solvent molecules: ","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"using PDBTools","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"(see Set solute and solvent for details).","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"The fastest way to understand how to use this package is through an example.  ","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Let us consider a system of three components: a protein, water, a cossolvent: TMAO (trimetylamine-N-oxyde), which is a common osmolyte known to stabilize protein structures. A picture of this system is shown below, with the protein in blue, water, and TMAO molecules. The system was constructed with Packmol and the figure was produced with VMD.","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"<img src=\"../figures/proteinTMAO.png\" width=60%>","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"We want to study the interactions of the protein with TMAO in this example. The computation of the MDDF is performed by defining the solute and solvent selections, and running the calculation on the trajectory.","category":"page"},{"location":"quickguide/#Define-the-protein-as-the-solute","page":"Quick Guide","title":"Define the protein as the solute","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"To define the protein as the solute, we will use the PDBTools package, which provides a handy selection syntax. First, read the PDB file using ","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"atoms = readPDB(\"./system.pdb\")\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Then, let us select the protein atoms (here we are using the PDBTools.select function):","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"protein = select(atoms,\"protein\")\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"And, finally, let us use the ComplexMixtures.Selection function to setup the structure required by the MDDF calculation:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"solute = ComplexMixtures.Selection(protein,nmols=1)\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"note: Note\nIt is necessary to indicate how many molecules (in this case, nmols=1, so that ComplexMixtures knows that the solute is to be considered as single structure. In this case there is no ambiguity, but if the solute was a miscele, for example, this option would let  ComplexMixtures know that one wants to consider the miscele as a single  structure.","category":"page"},{"location":"quickguide/#Define-TMAO-the-solvent-to-be-considered","page":"Quick Guide","title":"Define TMAO the solvent to be considered","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Equivalently, the solvent is set up with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"tmao = select(atoms,\"resname TMAO\")\nsolvent = ComplexMixtures.Selection(tmao,natomspermol=14)\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"note: Note\nHere we opted to provide the number of atoms of a TMAO molecules (with the natomspermol keyword). This is generally more practical for small molecules than to provide the number of molecules.","category":"page"},{"location":"quickguide/#Set-the-Trajectory-structure","page":"Quick Guide","title":"Set the Trajectory structure","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"The solute and solvent data structures are then fed into the Trajectory data structure, together with the trajectory file name, with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"trajectory = ComplexMixtures.Trajectory(\"trajectory.dcd\",solute,solvent)","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"In the case, the trajectory is of NAMD \"dcd\" format. All formats supported by Chemfiles  are automatically recognized. ","category":"page"},{"location":"quickguide/#Finally,-run-the-computation-and-get-the-results:","page":"Quick Guide","title":"Finally, run the computation and get the results:","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"If default options are used (as the bin size of the histograms, read all frames without skipping any), just run the mddf with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"results = ComplexMixtures.mddf(trajectory)\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Some optional parameters for the computation are available in the Options section.","category":"page"},{"location":"quickguide/#The-results-data-structure-obtained","page":"Quick Guide","title":"The results data structure obtained","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"The results data structure contains all the results of the MDDF calculation, including:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"results.d : Vector containing the distances to the solute. ","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"results.mddf : Vector containing the minimum-distance distribution function at each distance.","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"That means, for example, that ","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"plot(results.d,results.mddf,xlabel=\"d / \\AA\",ylabel=\"MDDF\") \n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"results in the expected plot of the MDDF of TMAO as a function of the distance to the protein:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"<img src=\"../figures/mddf.png\" width=\"60%\">\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"The Kirkwood-Buff integral corresponding to that distribution is provided in the results.kb vector, and can be also directly plotted  with   ","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"plot(results.d,results.kb,xlabel=\"d / \\AA\",ylabel=\"MDDF\") \n\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"to obtain:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"<img src=\"../figures/kb.png\" width=\"60%\">\n","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"See the Atomic and group contributions section for a detailed account on how to obtain a molecular picture of the solvation by splitting the MDDF in the contributions of each type of atom of the solvent, each type of residue of the protein, etc.","category":"page"},{"location":"quickguide/#Save-the-results","page":"Quick Guide","title":"Save the results","text":"","category":"section"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"The results can be saved into a file (with JSON format) with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"ComplexMixtures.save(results,\"./results.json\")","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"And these results can be loaded aftwerwards with:","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"ComplexMixtures.load(\"./results.json\")","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"Alternatively, a human-readable set of output files can be obtained to be analyzed in other software (or plotted with alternative tools), with","category":"page"},{"location":"quickguide/","page":"Quick Guide","title":"Quick Guide","text":"ComplexMixtures.write(results,\"./results.dat\")","category":"page"},{"location":"selection/#selections","page":"Set solute and solvent","title":"Set the solute and solvent selections","text":"","category":"section"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"The solute and solvent are defined in ComplexMixtures as lists (vectors) of the indexes of the atoms of the system. The solute and solvent information is stored in the Selection structure. For example, if the solute is a molecule formed by the first 5 atoms of the system, it would be defined as:     ","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"indexes = [ 1, 2, 3, 4, 5 ]\nsolute = ComplexMixtures.Selection(indexes,nmols=1)","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"note: Note\nWe need to inform the Selection function about the number of atoms of each molecule (using natomspermol=3, for example), or the number  of molecules (using nmols=1000, for example), such that the atoms belonging to each molecule can be determined without ambiguity. ","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"The atom names can be also provided such that some of the output files contain more information on the atomic contributions. In this case the syntax is:","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"indexes = [ 1, 2, 3, 4, 5 ]\nnames = [ \"H1\", \"H2\", \"H3\", \"H4\", \"C\" ]\nsolute = ComplexMixtures.Selection(indexes,names,nmols=1)","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"warning: Warning\nThe indexing in ComplexMixtures is 1-based. That means that the first atom of your structure file is in position 1 of the coordinates. Please be careful if using any selection tool to be sure that your selection is correct.","category":"page"},{"location":"selection/#Using-PDBTools","page":"Set solute and solvent","title":"Using PDBTools","text":"","category":"section"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"PDBTools is a package we developed to read and  write PDB files, which provides a simple selection tool. It is installed as a dependency  of ComplexMixtures.  Given a PDB file of the simulated system, the solute can be defined as, for example,","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"using PDBTools\natoms = PDBTools.readPDB(\"system.pdb\")\nprotein = PDBTools.select(atoms,\"protein\")\nsolute = ComplexMixtures.Selection(protein,nmols=1)","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"If the solvent is, for instance, water, the indexes of the water molecules can be obtained with:","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"water = PDBTools.select(atoms,\"water\")\nsolvent = ComplexMixtures.Selection(water,natomspermol=3)","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"or, alternatively, a more compact syntax can be used, for example:","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"water = PDBTools.select(\"system.pdb\",\"resname TIP3P\")\nsolvent = ComplexMixtures.Selection(water,natomspermol=3)","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"or even providing just the names of the input file and selection, which will run PDBTools in background:","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"solvent = ComplexMixtures.Selection(\"sytem.pdb\",\"water\",water,natomspermol=3)","category":"page"},{"location":"selection/#Using-VMD","page":"Set solute and solvent","title":"Using VMD","text":"","category":"section"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"VMD is a very popular and powerful package for visualization of simulations. It contains a very versatile library to read toppologies and trajectory files, and a powerful selection syntax. We provide here a wrapper to VMD which allows using its capabilities.  ","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"For example, the solute can be defined with: ","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"indexes, names = ComplexMixtures.VMDselect(\"./system.gro\",\"protein\",vmd=\"/usr/bin/vmd\")\nsolute = ComplexMixtures.Selection(indexes,names,nmols=1)","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"The main advantage here is that all the file types that VMD supports are supported. But VMD needs to be installed and is run in background, and it takes a few seconds.     ","category":"page"},{"location":"selection/","page":"Set solute and solvent","title":"Set solute and solvent","text":"warning: Warning\nVMD uses 0-based indexing and VMDselect adjusts that. However, if a selection is performed by index, as with index 1, VMD will select the second atom, and the output will be [2]. Selections by type, name, segment, residue name, etc, won't be a problem.","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Some tools are provided to analyze the results:","category":"page"},{"location":"tools/#Overview-of-the-solvent-and-solute-properties","page":"Tools","title":"Overview of the solvent and solute properties","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The output to the REPL of the Result structure provides an overview of the properties of the solution. The data can be retrieved into a data structure using the overview function. Examples:     ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"...\njulia> results = ComplexMixtures.mddf(trajectory)\n\njulia> results\n\n-------------------------------------------------------------------------------\n\n MDDF Overview: \n\n Solvent properties: \n ------------------- \n\n Simulation concentration: 1.5209006318095133 mol L⁻¹\n Molar volume: 657.5051512801567 cm³ mol⁻¹\n\n Concentration in bulk: 1.4918842545752287 mol L⁻¹\n Molar volume in bulk: 670.2932864484995 cm³ mol⁻¹ \n\n Solute properties: \n ------------------ \n\n Simulation Concentration: 1.5209006318095133 mol L⁻¹\n Estimated solute partial molar volume: 657.5051512801567 cm³ mol⁻¹\n\n Using with dbulk = 20.0Å: \n Molar volume of the solute domain: 30292.570006549242 cm³ mol⁻¹\n\n Auto-correlation: true\n\n Trajectory files and weights: \n   ./vinicius.xtc - w = 1.0\n\n Long range MDDF mean (expected 1.0): 1.1090804621839963 +/- 0.04298849642932878\n Long range RDF mean (expected 1.0): 1.15912932236198 +/- 0.05735018864444404\n\n-------------------------------------------------------------------------------\n","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"In this case, since solute and solvent are equivalent and the system is homogeneous, the molar volumes and concentrations are similar. This is not the case if the molecules are different or if the solute is at infinite dilution (in which case the bulk solvent density might be different from the solvent density in the simulation). ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"To retrieve the data of the overview strcture use, for example:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"julia> overview = ComplexMixtures.overview(results);\n\njulia> overview.solute_molar_volume\n657.5051512801567\n","category":"page"},{"location":"tools/#Computing-radial-distribution-functions","page":"Tools","title":"Computing radial distribution functions","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The distributions returned by the mddf function (meaning mddf and rdf) vectors, are normalized either the random reference state or using a site count based on the numerical integration of the volume corresponding to each minimum-distance to the solute. If, however, the solute is defined by a single atom (as the oxygen atom of water, for example), the numerical integration of the volume can be replaced by a simple analytical spherical shell volume, reducing noise. The gr function returns the radial distribution function and the KB integral  computed from the results, using this volume estimate: ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"g, kb = ComplexMixtures.gr(R)\n","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"By default, the single-reference count (rdf_count) of the Result structure will be used to compute the radial distribution function. The function can be called with explicit control of all input parameters: ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"g, kb = ComplexMixtures.gr(r,count,density,binstep)\n","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"where:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Parameter Definition Result structure output data to provide\nr Vector of distances The d vector\ncount Number of site counts at each r The rdf or mddf vectors\ndensity Bulk density The density.solvent_bulk or density.solvent densities.\nbinstep The histogram step The options.binstep\n  ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Example:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"...\nR = ComplexMixtures.mddf(trajectory,options)\ng, kb = ComplexMixtures.gr(R.d,R.rdf_count,R.density.solvent_bulk,R.options.binstep)\n","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"options/#options","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"There are some options to control what exactly is going to be computed to obtain the MDDF. These options can be defined by the user and passed to the mddf function, using, for example: ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"options = ComplexMixtures.Options(lastframe=1000)\nresults = ComplexMixtures.mddf(trajectory,options)","category":"page"},{"location":"options/#Most-common-options-that-the-user-might-want-to-control-are:","page":"Options","title":"Most common options that the user might want to control are:","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"firstframe: Integer, first frame of the trajectory to be considered.","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"lastframe: Integer, last frame of the trajectory to be considered.","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"stride: Integer, consider every stride frames, that is, if stride=5 only one in five frames will be considered.","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"binstep: Real, length of the bin step of the histograms, default = 0.02 Angstroms.","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"dbulk: Real, distance from which the solution is to be considered as a bulk solution, that is, where the presence of the solute does not affect the structure of the solution anymore. This parameter is important in particular for systems with a single solute molecule (a protein, for example), where the density of the solvent in the box is not the bulk density of the solvent, which must be computed independently. Default: 10 Angstroms. ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"cutoff: Real, the maximum distance to be considered in the construction of histograms. Default: 10 Angstroms. ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"usecutoff: true/false: If true, the cutoff distance might be different from dbulk and the density of the solvent in bulk will be estimated from the density within dbulk and cutoff. If false, the density of the solvent is estimated from the density outside dbulk by exclusion. Default: false. ","category":"page"},{"location":"options/#Options-that-most-users-will-probably-never-change:","page":"Options","title":"Options that most users will probably never change:","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"irefatom: Integer, index of the reference atom in the solvent molecule used to compute the shell volumes and domain volumes in the Monte-Carlo volume estimates. The final rdf data is reported for this atom as well. By default, we choose the atom which is closer to the center of coordinates of the molecule, but any choice should be fine. ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"n_random_samples: Integer, how many samples of random molecules are generated for each solvent molecule to compute the shell volumes and random MDDF counts. Default: 10. Increase this only if you have short trajectory and want to obtain reproducible results for that short trajectory. For long trajectories (most desirable and common), this value can even be decreased to speed up the calculations. ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"seed: Seed for random number generator. If -1, the seed will be generated from the entropy of the system. If your results are dependent on the seed, is is probable that you do not have enough sampling. Mostly used for testing purposes. Two runs are only identical if ran with the same seed and in serial mode.   ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"StableRNG (::Bool), defaults to false. Use a stable random number generator from the StableRNGs package, to produce identical runs on different architectures and Julia versions. Only used for testing. ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"nthreads: How many threads to use. By default, all available threads will be used (for multi-threading, one for managing, n-1 for computation).  ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"lcell: Integer, the cell length of the linked-cell method (actually the cell length is cutoff/lcell). Default: 2.  ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"sleep: Real, the time between checks between multiple spawns of calculations in parallel. Default 0.1 s. ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"GC: Bool, force garbage collection in parallel runs, to avoid memory overflow. Default: true. That this might be required is probably a result of something that can vastly improved in memory management. This may slow down parallel runs significantly if the GC runs too often.","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"GC_threshold: Float64, minimum fraction of the total memory of the system required to force a GC run. That is, if GC_threshold=0.1, which is the default, every time the free memory becomes less or equal to 10% of the total memory available, a GC run occurs.  ","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ComplexMixtures is a package to study the solute and solvent interactions of mixtures of molecules of complex shape. Conventional radial distribution functions are not appropriate to represent the structure of a solvent around a solute with many atoms, and a variable, non-spherical shape.     ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Typical solutes of complex shape are proteins, nucleic acids, and polymers in general. Smaller molecules like lipids, carbohydrates, etc, are also complex enough such that representing the structure of the solution of those molecules with distribution functions is not trivial.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Minimum-Distance Distribution Functions (MDDFs) are very general and practical way to represent solute-solvent interactions for molecules with arbitrarily complex sizes and geometries. In summary, instead of computing the density distribution function of a particular atom or the center-of-mass of the molecules, one computes the distribution function of the minimum-distance between any solute and solvent atoms. This provides a size and shape-independent distribution which is very natural to interpret in terms of molecular interactions.   ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additionally, the MDDFs can be decomposed into contributions of each type of atom (or groups of atoms) of the solute and solvent molecules, such that the profiles of the distributions can be interpreted in terms of the chemical nature of the species involved in the interactions at each distance.   ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, as with radial distribution functions, MDDFs can be used to compute Kirkwood-Buff integrals to connect the accumulation or depletion of the solvents components to thermodynamic properties, like protein structural stability, solubility, and others.","category":"page"}]
}
